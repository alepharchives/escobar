<html><link rel="stylesheet" type="text/css" href="http://erl-escobar.googlecode.com/svn/trunk/priv/escobar.css"></link><body><pre><span class="comment" >%%%-------------------------------------------------------------------</span>
<span class="comment" >%%% File    : escobar_tree.erl</span>
<span class="comment" >%%% Author  : Mats Cronqvist &lt;etxmacr@mwux005&gt;</span>
<span class="comment" >%%% Description :</span>
<span class="comment" >%%%</span>
<span class="comment" >%%% Created :  6 Jun 2005 by Mats Cronqvist &lt;etxmacr@mwux005&gt;</span>
<span class="comment" >%%%-------------------------------------------------------------------</span>
-<span class="attribute" >module</span>(escobar_hilite).

-<span class="attribute" >export</span>([<span class="export" >file/1</span>, <span class="export" >tree/1</span>, <span class="export" >string/1</span>, <span class="export" >out/2</span>]).

-<span class="attribute" >define</span>(<span class="macro" >LOG</span>(<span class="variable" >T</span>), <span class="call" >escobar:log</span>(<span class="builtin" >process_info</span>(<span class="builtin" >self</span>()), <span class="variable" >T</span>)).

-<span class="attribute" >import</span>(erl_syntax,
	[<span class="import" >get_ann/1</span>, <span class="import" >add_ann/2</span>, <span class="import" >subtrees/1</span>, <span class="import" >update_tree/2</span>, <span class="import" >type/1</span>, <span class="import" >get_pos/1</span>,
	 <span class="import" >application/2</span>, <span class="import" >application_arguments/1</span>, <span class="import" >application_operator/1</span>,
	 <span class="import" >arity_qualifier_argument/1</span>, <span class="import" >arity_qualifier_body/1</span>, <span class="import" >atom_name/1</span>, <span class="import" >atom_value/1</span>,
	 <span class="import" >attribute/2</span>, <span class="import" >attribute_name/1</span>, <span class="import" >attribute_arguments/1</span>, <span class="import" >clause/3</span>,
	 <span class="import" >clause_patterns/1</span>, <span class="import" >clause_guard/1</span>, <span class="import" >clause_body/1</span>, <span class="import" >comment/2</span>, <span class="import" >comment_text/1</span>,
	 <span class="import" >comment_padding/1</span>, <span class="import" >function/2</span>, <span class="import" >function_name/1</span>, <span class="import" >function_clauses/1</span>,
	 <span class="import" >function_arity/1</span>, <span class="import" >integer_literal/1</span>, <span class="import" >list/1</span>, <span class="import" >list_elements/1</span>, <span class="import" >macro/2</span>,
	 <span class="import" >macro_name/1</span>, <span class="import" >macro_arguments/1</span>, <span class="import" >module_qualifier_body/1</span>,
	 <span class="import" >module_qualifier_argument/1</span>, <span class="import" >string_value/1</span>, <span class="import" >string_literal/1</span>,
	 <span class="import" >variable_literal/1</span>, <span class="import" >variable_name/1</span>, <span class="import" >record_access/3</span>, <span class="import" >record_access_argument/1</span>,
	 <span class="import" >record_access_field/1</span>, <span class="import" >record_access_type/1</span>, <span class="import" >record_expr/3</span>,
	 <span class="import" >record_expr_argument/1</span>, <span class="import" >record_expr_fields/1</span>, <span class="import" >record_expr_type/1</span>,
	 <span class="import" >record_index_expr/2</span>, <span class="import" >record_index_expr_field/1</span>, <span class="import" >record_index_expr_type/1</span>,
	 <span class="import" >form_list/1</span>, <span class="import" >get_precomments/1</span>, <span class="import" >get_postcomments/1</span>, <span class="import" >has_comments/1</span>,
	 <span class="import" >copy_comments/2</span>, <span class="import" >remove_comments/1</span>]).

-<span class="attribute" >import</span>(prettypr,
	[<span class="import" >above/2</span>, <span class="import" >follow/2</span>, <span class="import" >beside/2</span>, <span class="import" >empty/0</span>, <span class="import" >null_text/1</span>, <span class="import" >break/1</span>, <span class="import" >floating/3</span>, <span class="import" >text/1</span>,
	 <span class="import" >floating/1</span>]).

-<span class="attribute" >import</span>(lists, [<span class="import" >flatten/1</span>, <span class="import" >duplicate/2</span>, <span class="import" >keysearch/3</span>, <span class="import" >member/2</span>, <span class="import" >usort/1</span>, <span class="import" >reverse/1</span>]).

-<span class="attribute" >import</span>(filename, [<span class="import" >join/1</span>, <span class="import" >basename/1</span>]).

<span class="function" >out</span>(<span class="variable" >File</span>, <span class="variable" >HtmlString</span>) ->
    {ok, <span class="variable" >FD</span>} = <span class="call" >file:open</span>(<span class="variable" >File</span>, [write]),
    try
      <span class="call" >io:fwrite</span>(<span class="variable" >FD</span>, <span class="string" >"&lt;html&gt;"</span>, []),
      <span class="call" >io:fwrite</span>(<span class="variable" >FD</span>, <span class="string" >"&lt;link rel=\"stylesheet\" type=\"text/css\""</span>, []),
      <span class="call" >io:fwrite</span>(<span class="variable" >FD</span>, <span class="string" >"href=\"escobar.css\"&gt;&lt;/link&gt;&lt;body&gt;&lt;pre&gt;"</span>, []),
      <span class="call" >io:fwrite</span>(<span class="variable" >FD</span>, <span class="string" >"~s"</span>, [<span class="variable" >HtmlString</span>]),
      <span class="call" >io:fwrite</span>(<span class="variable" >FD</span>, <span class="string" >"&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;"</span>, [])
    after
      <span class="call" >file:close</span>(<span class="variable" >FD</span>)
    end.

<span class="function" >string</span>(<span class="variable" >Str</span>) -> <span class="call" >tree</span>(<span class="call" >form_list</span>(<span class="call" >scan_and_parse</span>(<span class="variable" >Str</span>, 1, []))).

<span class="function" >scan_and_parse</span>([], <span class="variable" >_Line</span>, <span class="variable" >Forms</span>) -> <span class="call" >reverse</span>(<span class="variable" >Forms</span>);
<span class="function" >scan_and_parse</span>(<span class="variable" >Text</span>, <span class="variable" >Line</span>, <span class="variable" >Forms</span>) ->
    {done, {ok, <span class="variable" >Toks</span>, <span class="variable" >NLine</span>}, <span class="variable" >Cont</span>} = <span class="call" >erl_scan:tokens</span>([], <span class="variable" >Text</span>, <span class="variable" >Line</span>),
    {ok, <span class="variable" >Form</span>} = <span class="call" >erl_parse:parse_form</span>(<span class="variable" >Toks</span>),
    <span class="call" >scan_and_parse</span>(<span class="variable" >Cont</span>, <span class="variable" >NLine</span>, [<span class="variable" >Form</span> | <span class="variable" >Forms</span>]).

<span class="function" >file</span>(<span class="variable" >FileName</span>) ->
    case <span class="call" >filelib:is_regular</span>(<span class="variable" >FileName</span>) of
      true ->
	  case <span class="call" >filename:extension</span>(<span class="variable" >FileName</span>) of
	    <span class="string" >".beam"</span> -> <span class="call" >tree</span>(<span class="call" >get_tree_beam</span>(<span class="variable" >FileName</span>));
	    <span class="string" >".erl"</span> -> <span class="call" >tree</span>(<span class="call" >get_comm_tree_erl</span>(<span class="variable" >FileName</span>));
	    <span class="string" >".hrl"</span> -> <span class="call" >tree</span>(<span class="call" >get_comm_tree_erl</span>(<span class="variable" >FileName</span>));
	    <span class="variable" >X</span> -> <span class="builtin" >erlang:error</span>({unknown_extension, <span class="variable" >X</span>})
	  end;
      false -> <span class="builtin" >erlang:error</span>({no_file, <span class="variable" >FileName</span>})
    end.

<span class="function" >get_comm_tree_erl</span>(<span class="variable" >Filename</span>) ->
    <span class="variable" >Comms</span> = <span class="call" >erl_comment_scan:file</span>(<span class="variable" >Filename</span>),
    <span class="variable" >Forms</span> = <span class="call" >get_forms_erl</span>(<span class="variable" >Filename</span>),
    <span class="call" >erl_recomment:recomment_forms</span>(<span class="variable" >Forms</span>, <span class="variable" >Comms</span>).

<span class="function" >get_tree_beam</span>(<span class="variable" >Filename</span>) ->
    case <span class="call" >beam_lib:chunks</span>(<span class="variable" >Filename</span>, [<span class="string" >"Abst"</span>]) of
      {ok, {_, [{<span class="string" >"Abst"</span>, <span class="variable" >AChunk</span>}]}} ->
	  {_, <span class="variable" >Forms</span>} = <span class="builtin" >binary_to_term</span>(<span class="variable" >AChunk</span>), <span class="call" >form_list</span>(<span class="variable" >Forms</span>);
      _ -> <span class="builtin" >erlang:error</span>({no_debuginfo, <span class="variable" >Filename</span>})
    end.

<span class="function" >get_forms_erl</span>(<span class="variable" >Filename</span>) ->
    {ok, <span class="variable" >Fs</span>} = <span class="call" >epp_dodger:parse_file</span>(<span class="variable" >Filename</span>, [{no_fail, true}]), <span class="variable" >Fs</span>.

<span class="comment" >%%% # tree
%%% turn a syntax tree into html by annotating and pretty-printing
%%% with a hook function
</span>

<span class="function" >tree</span>(<span class="variable" >Tree</span>) -> <span class="call" >pout</span>(<span class="call" >ann</span>(<span class="call" >type</span>(<span class="variable" >Tree</span>), <span class="variable" >Tree</span>)).

<span class="comment" >%%lists:foldl(fun(Form,Acc) -&gt; [pout(ann(Form))|Acc] end, [], Tree).
</span>

<span class="function" >pout</span>(<span class="variable" >Form</span>) -> <span class="call" >erl_prettypr:format</span>(<span class="variable" >Form</span>, [{hook, fun tag/3}, {paper, 90}, {ribbon, 650}]).

<span class="comment" >%%% ## formatting</span>
<span class="comment" >%%% ### 'tag' - the format hook function</span>
<span class="function" >tag</span>(<span class="variable" >Node</span>, <span class="variable" >Ctxt</span>, <span class="variable" >Cont</span>) ->
    <span class="variable" >Tags</span> = <span class="call" >get_ann</span>(<span class="variable" >Node</span>),
    case <span class="call" >member</span>(has_comment, <span class="variable" >Tags</span>) of
      true ->
	  <span class="variable" >PreC</span> = <span class="call" >get_precomments</span>(<span class="variable" >Node</span>),
	  <span class="variable" >PostC</span> = <span class="call" >get_postcomments</span>(<span class="variable" >Node</span>),
	  <span class="variable" >Nod</span> = <span class="call" >remove_comments</span>(<span class="variable" >Node</span>),
	  <span class="variable" >Doc0</span> = <span class="call" >tagit</span>(<span class="variable" >Tags</span> -- [has_comment], <span class="variable" >Cont</span>(<span class="variable" >Nod</span>, <span class="variable" >Ctxt</span>)),
	  <span class="call" >postcomment</span>(<span class="call" >precomment</span>(<span class="variable" >Doc0</span>, <span class="variable" >PreC</span>), <span class="variable" >PostC</span>);
      false -> <span class="variable" >Doc0</span> = <span class="variable" >Cont</span>(<span class="variable" >Node</span>, <span class="variable" >Ctxt</span>), <span class="call" >tagit</span>(<span class="variable" >Tags</span>, <span class="variable" >Doc0</span>)
    end.

<span class="function" >tagit</span>([], <span class="variable" >Doc0</span>) -> <span class="variable" >Doc0</span>;
<span class="function" >tagit</span>([<span class="string" >"binary"</span>], {beside, _, {beside, <span class="variable" >Doc</span>, _}}) ->
    <span class="call" >beside</span>(<span class="call" >floating</span>(<span class="call" >text</span>(<span class="string" >"&lt;&lt;"</span>)), <span class="call" >beside</span>(<span class="variable" >Doc</span>, <span class="call" >floating</span>(<span class="call" >text</span>(<span class="string" >"&gt;&gt;"</span>))));
<span class="function" >tagit</span>([<span class="variable" >Tag</span>], <span class="variable" >Doc0</span>) -> <span class="call" >beside</span>(<span class="call" >null_text</span>(<span class="variable" >Tag</span>), <span class="call" >beside</span>(<span class="variable" >Doc0</span>, <span class="call" >null_text</span>(<span class="call" >etag</span>(<span class="variable" >Tag</span>)))).

<span class="function" >etag</span>(<span class="string" >"&lt;"</span> ++ <span class="variable" >Tag</span>) -> <span class="string" >"&lt;/"</span> ++ <span class="builtin" >hd</span>(<span class="call" >string:tokens</span>(<span class="variable" >Tag</span>, <span class="string" >" "</span>)) ++ <span class="string" >"&gt;"</span>.

<span class="comment" >%%%### comment stuff</span>
<span class="function" >precomment</span>(<span class="variable" >Doc</span>, <span class="variable" >PreC</span>) -> <span class="call" >above</span>(<span class="call" >floating</span>(<span class="call" >break</span>(<span class="call" >stack</span>(<span class="variable" >PreC</span>)), -1, -1), <span class="variable" >Doc</span>).

<span class="function" >postcomment</span>(<span class="variable" >Doc</span>, <span class="variable" >PostC</span>) -> <span class="call" >beside</span>(<span class="variable" >Doc</span>, <span class="call" >floating</span>(<span class="call" >break</span>(<span class="call" >stack</span>(<span class="variable" >PostC</span>)), 1, 0)).

<span class="function" >stack</span>([]) -> <span class="call" >empty</span>();
<span class="function" >stack</span>([<span class="variable" >Comm</span> | <span class="variable" >Comms</span>]) ->
    <span class="variable" >Doc</span> = <span class="call" >maybe_pad</span>(<span class="call" >stack_comment_lines</span>(<span class="call" >comment_text</span>(<span class="variable" >Comm</span>)), <span class="variable" >Comm</span>),
    case <span class="variable" >Comms</span> of
      [] -> <span class="variable" >Doc</span>;
      _ -> <span class="call" >above</span>(<span class="variable" >Doc</span>, <span class="call" >stack</span>(<span class="variable" >Comms</span>))
    end.

<span class="function" >maybe_pad</span>(<span class="variable" >Doc</span>, <span class="variable" >Comm</span>) ->
    case <span class="call" >comment_padding</span>(<span class="variable" >Comm</span>) of
      <span class="variable" >I</span> when <span class="builtin" >is_integer</span>(<span class="variable" >I</span>), 0 < <span class="variable" >I</span> -> <span class="call" >beside</span>(<span class="call" >text</span>(<span class="call" >duplicate</span>(<span class="variable" >I</span>, $\s)), <span class="variable" >Doc</span>);
      _ -> <span class="variable" >Doc</span>
    end.

<span class="comment" >%%% stolen with pride from erl_prettypr
%%% Stack lines of text above each other and prefix each string in
%%% the list with a single `%' character.
</span>

<span class="function" >stack_comment_lines</span>([<span class="variable" >S</span> | <span class="variable" >Ss</span>]) ->
    <span class="variable" >D</span> = <span class="call" >tagit</span>([<span class="call" >dehtml</span>(span, [{class, comment}])], <span class="call" >text</span>(<span class="string" >"%"</span> ++ <span class="call" >debracket</span>(<span class="variable" >S</span>))),
    case <span class="variable" >Ss</span> of
      [] -> <span class="variable" >D</span>;
      _ -> <span class="call" >above</span>(<span class="variable" >D</span>, <span class="call" >stack_comment_lines</span>(<span class="variable" >Ss</span>))
    end;
<span class="function" >stack_comment_lines</span>([]) -> <span class="call" >empty</span>().

<span class="comment" >%%% annotate nodes that should be hilited
%%% the annotation is put on the subtree that should be marked up
%%% the annotation is;
%%% has_comments|Markup
%%% if a node already has an annotation the new one is dropped, except
%%% if either the new or the old one is has_comments
</span>

<span class="function" >ann</span>(binary, <span class="variable" >Tree</span>) -> <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="call" >add_anno</span>(<span class="string" >"binary"</span>, <span class="variable" >Tree</span>));
<span class="function" >ann</span>(application, <span class="variable" >Tree</span>) ->
    <span class="variable" >Op</span> = <span class="call" >application_operator</span>(<span class="variable" >Tree</span>),
    <span class="variable" >Args</span> = <span class="call" >application_arguments</span>(<span class="variable" >Tree</span>),
    <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="call" >application</span>(<span class="call" >add_anno</span>(<span class="call" >mu</span>(application, <span class="variable" >Tree</span>), <span class="variable" >Op</span>), <span class="variable" >Args</span>));
<span class="function" >ann</span>(attribute, <span class="variable" >Tree</span>) ->
    <span class="variable" >Name</span> = <span class="call" >attribute_name</span>(<span class="variable" >Tree</span>),
    case <span class="call" >atom_value</span>(<span class="variable" >Name</span>) of
      export ->
	  <span class="variable" >AQs</span> = <span class="call" >list_elements</span>(<span class="builtin" >hd</span>(<span class="call" >attribute_arguments</span>(<span class="variable" >Tree</span>))),
	  <span class="variable" >Args</span> = [<span class="guard" >list</span>([<span class="call" >add_anno</span>(<span class="call" >mu</span>(export, <span class="variable" >Tree</span>), <span class="variable" >AQ</span>) || <span class="variable" >AQ</span> <- <span class="variable" >AQs</span>])];
      import ->
	  [<span class="variable" >ImportMod</span>, <span class="variable" >ImportFAs</span>] = <span class="call" >attribute_arguments</span>(<span class="variable" >Tree</span>),
	  <span class="variable" >AQs</span> = <span class="call" >list_elements</span>(<span class="variable" >ImportFAs</span>),
	  <span class="variable" >Args</span> = [<span class="variable" >ImportMod</span>, <span class="guard" >list</span>([<span class="call" >add_anno</span>(<span class="call" >mu</span>(import, <span class="variable" >Tree</span>), <span class="variable" >AQ</span>) || <span class="variable" >AQ</span> <- <span class="variable" >AQs</span>])];
      define ->
	  [<span class="variable" >Macro</span> | <span class="variable" >Rest</span>] = <span class="call" >attribute_arguments</span>(<span class="variable" >Tree</span>),
	  case <span class="call" >type</span>(<span class="variable" >Macro</span>) of
	    application ->
		<span class="variable" >Op</span> = <span class="call" >application_operator</span>(<span class="variable" >Macro</span>),
		<span class="variable" >As</span> = <span class="call" >application_arguments</span>(<span class="variable" >Macro</span>),
		<span class="variable" >Args</span> = [<span class="call" >application</span>(<span class="call" >add_anno</span>(<span class="call" >mu</span>(macro, <span class="variable" >Tree</span>), <span class="variable" >Op</span>), <span class="variable" >As</span>) | <span class="variable" >Rest</span>];
	    _ -> <span class="variable" >Args</span> = [<span class="call" >add_anno</span>(<span class="call" >mu</span>(macro, <span class="variable" >Tree</span>), <span class="variable" >Macro</span>) | <span class="variable" >Rest</span>]
	  end;
      record ->
	  [<span class="variable" >Rec</span> | <span class="variable" >Rest</span>] = <span class="call" >attribute_arguments</span>(<span class="variable" >Tree</span>),
	  <span class="variable" >Args</span> = [<span class="call" >add_anno</span>(<span class="call" >mu</span>(record, <span class="variable" >Tree</span>), <span class="variable" >Rec</span>) | <span class="variable" >Rest</span>];
      _ -> <span class="variable" >Args</span> = <span class="call" >attribute_arguments</span>(<span class="variable" >Tree</span>)
    end,
    <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="call" >attribute</span>(<span class="call" >add_anno</span>(<span class="call" >mu</span>(attribute, <span class="variable" >Tree</span>), <span class="variable" >Name</span>), <span class="variable" >Args</span>));
<span class="function" >ann</span>(record_access, <span class="variable" >Tree</span>) ->
    <span class="variable" >Arg</span> = <span class="call" >record_access_argument</span>(<span class="variable" >Tree</span>),
    <span class="variable" >Type</span> = <span class="call" >record_access_type</span>(<span class="variable" >Tree</span>),
    <span class="variable" >Field</span> = <span class="call" >record_access_field</span>(<span class="variable" >Tree</span>),
    <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="call" >record_access</span>(<span class="variable" >Arg</span>, <span class="call" >add_anno</span>(<span class="call" >mu</span>(record, <span class="variable" >Tree</span>), <span class="variable" >Type</span>), <span class="variable" >Field</span>));
<span class="function" >ann</span>(record_expr, <span class="variable" >Tree</span>) ->
    <span class="variable" >Arg</span> = <span class="call" >record_expr_argument</span>(<span class="variable" >Tree</span>),
    <span class="variable" >Type</span> = <span class="call" >record_expr_type</span>(<span class="variable" >Tree</span>),
    <span class="variable" >Fields</span> = <span class="call" >record_expr_fields</span>(<span class="variable" >Tree</span>),
    <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="call" >record_expr</span>(<span class="variable" >Arg</span>, <span class="call" >add_anno</span>(<span class="call" >mu</span>(record, <span class="variable" >Tree</span>), <span class="variable" >Type</span>), <span class="variable" >Fields</span>));
<span class="function" >ann</span>(record_index_expr, <span class="variable" >Tree</span>) ->
    <span class="variable" >Type</span> = <span class="call" >record_index_expr_type</span>(<span class="variable" >Tree</span>),
    <span class="variable" >Field</span> = <span class="call" >record_index_expr_field</span>(<span class="variable" >Tree</span>),
    <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="call" >record_index_expr</span>(<span class="call" >add_anno</span>(<span class="call" >mu</span>(record, <span class="variable" >Tree</span>), <span class="variable" >Type</span>), <span class="variable" >Field</span>));
<span class="function" >ann</span>(function, <span class="variable" >Tree</span>) ->
    <span class="variable" >Name</span> = <span class="call" >function_name</span>(<span class="variable" >Tree</span>),
    <span class="variable" >Clauses</span> = <span class="call" >function_clauses</span>(<span class="variable" >Tree</span>),
    <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="guard" >function</span>(<span class="call" >add_anno</span>(<span class="call" >mu</span>(function, <span class="variable" >Tree</span>), <span class="variable" >Name</span>), <span class="variable" >Clauses</span>));
<span class="function" >ann</span>(macro, <span class="variable" >Tree</span>) ->
    <span class="variable" >Name</span> = <span class="call" >macro_name</span>(<span class="variable" >Tree</span>),
    <span class="variable" >Args</span> = <span class="call" >macro_arguments</span>(<span class="variable" >Tree</span>),
    <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="call" >macro</span>(<span class="call" >add_anno</span>(<span class="call" >mu</span>(macro, <span class="variable" >Tree</span>), <span class="variable" >Name</span>), <span class="variable" >Args</span>));
<span class="function" >ann</span>(string, <span class="variable" >OTree</span>) ->
    <span class="variable" >Tree</span> = <span class="call" >erl_syntax:string</span>(<span class="call" >debracket</span>(<span class="call" >string_value</span>(<span class="variable" >OTree</span>))),
    <span class="call" >new_tree</span>(<span class="variable" >OTree</span>, <span class="call" >add_anno</span>(<span class="call" >mu</span>(string, <span class="variable" >OTree</span>), <span class="variable" >Tree</span>));
<span class="function" >ann</span>(variable, <span class="variable" >Tree</span>) -> <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="call" >add_anno</span>(<span class="call" >mu</span>(variable, <span class="variable" >Tree</span>), <span class="variable" >Tree</span>));
<span class="function" >ann</span>(text, <span class="variable" >Tree</span>) -> <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="call" >add_anno</span>(<span class="call" >mu</span>(error, <span class="variable" >Tree</span>), <span class="variable" >Tree</span>));
<span class="function" >ann</span>(comment, <span class="variable" >OTree</span>) ->
    <span class="variable" >Pad</span> = <span class="call" >comment_padding</span>(<span class="variable" >OTree</span>),
    <span class="variable" >Text</span> = [<span class="call" >debracket</span>(<span class="variable" >S</span>) || <span class="variable" >S</span> <- <span class="call" >comment_text</span>(<span class="variable" >OTree</span>)],
    <span class="variable" >Tree</span> = <span class="call" >comment</span>(<span class="variable" >Pad</span>, <span class="variable" >Text</span>),
    <span class="call" >new_tree</span>(<span class="variable" >OTree</span>, <span class="call" >add_anno</span>(<span class="call" >mu</span>(comment, <span class="variable" >OTree</span>), <span class="variable" >Tree</span>));
<span class="function" >ann</span>(<span class="variable" >_Typ</span>, <span class="variable" >Tree</span>) -> <span class="call" >new_tree</span>(<span class="variable" >Tree</span>, <span class="variable" >Tree</span>).

<span class="function" >new_tree</span>(<span class="variable" >OTree</span>, <span class="variable" >NTree</span>) ->
    <span class="variable" >Tree</span> = case <span class="call" >has_comments</span>(<span class="variable" >OTree</span>) of
	     true -> <span class="call" >add_ann</span>(has_comment, <span class="call" >copy_comments</span>(<span class="variable" >OTree</span>, <span class="variable" >NTree</span>));
	     false -> <span class="variable" >NTree</span>
	   end,
    <span class="variable" >SubTrees</span> = <span class="call" >subtrees</span>(<span class="variable" >Tree</span>),
    case [[<span class="call" >ann</span>(<span class="call" >type</span>(<span class="variable" >SubT</span>), <span class="variable" >SubT</span>) || <span class="variable" >SubT</span> <- <span class="variable" >Group</span>] || <span class="variable" >Group</span> <- <span class="variable" >SubTrees</span>] of
      [] -> <span class="variable" >Tree</span>;
      <span class="variable" >NSubtrees</span> -> <span class="call" >update_tree</span>(<span class="variable" >Tree</span>, <span class="variable" >NSubtrees</span>)
    end.

<span class="function" >debracket</span>([]) -> [];
<span class="function" >debracket</span>([$> | <span class="variable" >Str</span>]) -> <span class="string" >"&gt;"</span> ++ <span class="call" >debracket</span>(<span class="variable" >Str</span>);
<span class="function" >debracket</span>([$< | <span class="variable" >Str</span>]) -> <span class="string" >"&lt;"</span> ++ <span class="call" >debracket</span>(<span class="variable" >Str</span>);
<span class="function" >debracket</span>([<span class="variable" >C</span> | <span class="variable" >Str</span>]) -> [<span class="variable" >C</span> | <span class="call" >debracket</span>(<span class="variable" >Str</span>)].

<span class="function" >add_anno</span>(nil, <span class="variable" >Tree</span>) -> <span class="variable" >Tree</span>;
<span class="function" >add_anno</span>(<span class="variable" >Ann</span>, <span class="variable" >Tree</span>) ->
    case <span class="call" >get_ann</span>(<span class="variable" >Tree</span>) of
      [] -> <span class="call" >add_ann</span>(<span class="variable" >Ann</span>, <span class="variable" >Tree</span>);
      [has_comment] -> <span class="call" >add_ann</span>(<span class="variable" >Ann</span>, <span class="variable" >Tree</span>);
      <span class="variable" >_OAnn</span> -> <span class="variable" >Tree</span>
    end.

<span class="comment" >%%%### the markups</span>
<span class="function" >mu</span>(application, <span class="variable" >Node</span>) ->
    <span class="variable" >Op</span> = <span class="call" >application_operator</span>(<span class="variable" >Node</span>),
    <span class="variable" >Ar</span> = <span class="builtin" >length</span>(<span class="call" >application_arguments</span>(<span class="variable" >Node</span>)),
    case <span class="call" >type</span>(<span class="variable" >Op</span>) of
      <span class="comment" >%%     variable -&gt;</span>
      <span class="comment" >%%       dehtml('span', [{class,variable}]);</span>
      atom ->
	  case <span class="call" >is_guard_or_builtin</span>(<span class="call" >atom_value</span>(<span class="variable" >Op</span>), <span class="variable" >Ar</span>) of
	    guard -> <span class="call" >dehtml</span>(span, [{class, guard}]);
	    builtin -> <span class="call" >dehtml</span>(span, [{class, builtin}]);
	    neither -> <span class="call" >dehtml</span>(span, [{class, call}])
	  end;
      module_qualifier ->
	  <span class="variable" >Mod</span> = <span class="call" >module_qualifier_argument</span>(<span class="variable" >Op</span>),
	  <span class="variable" >Fun</span> = <span class="call" >module_qualifier_body</span>(<span class="variable" >Op</span>),
	  case {<span class="call" >type</span>(<span class="variable" >Mod</span>), <span class="call" >type</span>(<span class="variable" >Fun</span>)} of
	    {atom, atom} ->
		case <span class="call" >atom_value</span>(<span class="variable" >Mod</span>) of
		  erlang -> <span class="call" >dehtml</span>(span, [{class, builtin}]);
		  _ -> <span class="call" >dehtml</span>(span, [{class, call}])
		end;
	    _ -> nil
	  end;
      _ -> nil
    end;
<span class="function" >mu</span>(<span class="variable" >Class</span>, <span class="variable" >_Node</span>) -> <span class="call" >dehtml</span>(span, [{class, <span class="variable" >Class</span>}]).

<span class="function" >dehtml</span>(<span class="variable" >Tag</span>, <span class="variable" >Atts</span>) ->
    <span class="call" >flatten</span>([$<, <span class="call" >str</span>(<span class="variable" >Tag</span>), $\s, [[<span class="call" >str</span>(<span class="variable" >A</span>), <span class="string" >"=\""</span>, <span class="call" >str</span>(<span class="variable" >V</span>), <span class="string" >"\" "</span>] || {<span class="variable" >A</span>, <span class="variable" >V</span>} <- <span class="variable" >Atts</span>], $>]).

<span class="function" >str</span>(<span class="variable" >I</span>) when <span class="guard" >integer</span>(<span class="variable" >I</span>) -> <span class="builtin" >integer_to_list</span>(<span class="variable" >I</span>);
<span class="function" >str</span>(<span class="variable" >A</span>) when <span class="guard" >atom</span>(<span class="variable" >A</span>) -> <span class="builtin" >atom_to_list</span>(<span class="variable" >A</span>);
<span class="function" >str</span>(<span class="variable" >L</span>) when <span class="guard" >list</span>(<span class="variable" >L</span>) -> <span class="variable" >L</span>.

<span class="function" >is_guard_or_builtin</span>(atom, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(binary, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(constant, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(float, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(function, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(function, 2) -> guard;
<span class="function" >is_guard_or_builtin</span>(integer, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(list, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(number, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(pid, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(port, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(reference, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(tuple, 1) -> guard;
<span class="function" >is_guard_or_builtin</span>(record, 2) -> guard;
<span class="function" >is_guard_or_builtin</span>(record, 3) -> guard;
<span class="function" >is_guard_or_builtin</span>(<span class="variable" >F</span>, <span class="variable" >A</span>) ->
    case <span class="builtin" >erlang:function_exported</span>(erlang, <span class="variable" >F</span>, <span class="variable" >A</span>) orelse <span class="builtin" >erlang:is_builtin</span>(erlang, <span class="variable" >F</span>, <span class="variable" >A</span>) of
      true -> builtin;
      false -> neither
    end.</pre></body></html>